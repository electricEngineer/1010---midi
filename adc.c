/***********************************************************************
MODULE:    ADC
VERSION:   1.02
CONTAINS:  Routines for controlling the ADC-DAC peripheral on the
           P89LPC936
COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
LICENSE:   May be freely used in commercial and non-commercial code
           without royalties provided this copyright notice remains
           in this file and unaltered
WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
           MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
           TO CHANGE THE CONTENTS OF THIS FILE
GENERATED: On "Sep 30 2010" at "21:16:49" by Code Architect 2.06
***********************************************************************/

//#pragma code
// SFR description needs to be included
#include <reg936.h>
#include "itrip.h"
#include "adc.h"

/************************exterN GLOBOLS********************************/
extern volatile byte adcFlag;
extern volatile byte adcVal[2];
/***********************************************************************
DESC:    Initializes the ADC
RETURNS: Nothing
CAUTION: Set EA to 1 after calling to enable all interrupts
************************************************************************/
void adc_init
  (
  void
  )
{
  // configure clock divider 
  ADMODB |= 0x40;

  // set adc1 channel pins to input only (disables digital output)
  // channel 2
  P0M1 |= 0x08;
  P0M2 &= ~0x08;
  // disable dac1
  ADMODB &= ~0x08;
  // configure adc1 and enable (also enables dac1)
  ADCON1 |= 0x44;

  // set isr priority to 0
  IP1 &= 0x7F;
  IP1H &= 0x7F;

  // enable adc interrupt
  EAD = 1;
}

/***********************************************************************
DESC:    Configures ADC1 and starts conversions
         If trigger = ADC_NONE then ADC1 is configured and no conversions
         are started
RETURNS: Nothing
************************************************************************/
void adc_startadc1conversion
  (
    unsigned char trigger,   // ADC_TIMER, ADC_IMMEDIATE, ADC_EDGE, ADC_DUALIMMEDIATE, ADC_NONE
    unsigned char mode,      // ADC_FIXEDSINGLE    (select one channel in channels)
                             // ADC_FIXEDCONT      (select one channel in channels)
                             // ADC_AUTOSCANSINGLE (select one to four channels in channels)
                             // ADC_AUTOSCANCONT   (select one to four channels in channels)
                             // ADC_DUALCONT       (select two channels in channels)
                             // ADC_SINGLESTEP     (select one to four channels in channels)
    unsigned char channels   // one or more of: ADC1_CHANNEL0, ADC1_CHANNEL1, ADC1_CHANNEL2, ADC1_CHANNEL3
  )
{
  // disable all triggers
  ADCON1 &= 0xDC;
  // clear mode bits and boundary interrupt flag
  ADMODA &= 0x0F;

  switch (mode)
  {
    // fixed channel, single conversion
    case ADC_FIXEDSINGLE:
    // auto scan, single conversion
    case ADC_AUTOSCANSINGLE:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x10;
      break;
    // fixed channel, continuous conversion
    case ADC_FIXEDCONT:
    // dual channel, continuous conversion
    case ADC_DUALCONT:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x20;
      break;
    // auto scan, continuous conversion
    case ADC_AUTOSCANCONT:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x40;
        break;
    // single step
    case ADC_SINGLESTEP:
      // select channel(s)
      ADINS = channels;
      break;
  }

  // select new trigger
  switch (trigger)
  {
    // no trigger
    case ADC_NONE:
      break;
    // timer triggered start
    case ADC_TIMER:
      // select trigger
      ADCON1 |= 0x20;
      break;
    // start immedately
    case ADC_IMMEDIATE:
      // select trigger
      ADCON1 |= 0x01;
      break;
    // edge triggered start
    case ADC_EDGE:
      // select trigger
      ADCON1 |= 0x02;
      break;
    // dual start immediately
    case ADC_DUALIMMEDIATE:
      // select trigger
      ADCON1 |= 0x03;
      break;
  }
}

/***********************************************************************
DESC:    Stops ADC1 conversions
RETURNS: Nothing
************************************************************************/
void adc_stopadc1conversion
  (						   
  void
  )
{
  // disable all triggers
  ADCON1 &= 0xDC;
}

/***********************************************************************
DESC:    ADC Interrupt Service Routine
         Called when an ADC conversion has completed
         Uses register bank 3
RETURNS: Nothing
CAUTION: adc_init must be called first
TIME:	 6 instructions, "mycode" = 20 intstructions , 6 instructions
************************************************************************/
void adc_isr
  (
  void
  ) interrupt 14 using 3
{
  // adc1 conversion complete?
  if (ADCON1 & 0x08)
  {
    // clear ADCI1 flag
    ADCON1 &= ~0x08;
    
	//mycode........................
	adcVal[0] = adcVal[1];
	adcVal[1] = AD1DAT2; 
	if ((adcVal[0] > 15) && (adcVal[1] > 15))
		adcFlag = 1;
	else {adcFlag = 0;}
	//mycodeend

  }
//  // adc1 outside boundary range?
//  if (ADMODA & 0x80)
//  {
//    // clear BND1 flag
//    ADMODA &= ~0x80;
//  }
}


