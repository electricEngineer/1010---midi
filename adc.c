/***********************************************************************
MODULE:    ADC
VERSION:   1.02
CONTAINS:  Routines for controlling the ADC-DAC peripheral on the
           P89LPC936
COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
LICENSE:   May be freely used in commercial and non-commercial code
           without royalties provided this copyright notice remains
           in this file and unaltered
WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
           MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
           TO CHANGE THE CONTENTS OF THIS FILE
GENERATED: On "Jul 07 2016" at "10:48:45" by Code Architect 2.06
***********************************************************************/

// SFR description needs to be included
#include <reg936.h>
#include "adc.h"
#include "itrip.h"

/***********************************************************************
DESC:    Initializes the ADC
RETURNS: Nothing
CAUTION: Set EA to 1 after calling to enable all interrupts
************************************************************************/
void adc_init
  (
  void
  )
{
  // configure clock divider
  ADMODB |= 0x40;

  // set adc0 channel pins to input only (disables digital output)
  // channel 0
  P1M1 |= 0x80;
  P1M2 &= ~0x80;
  // channel 2
  P2M1 |= 0x02;
  P2M2 &= ~0x02;
  // disable dac0
  ADMODB &= ~0x04;
  // configure adc0 and enable (also enables dac0)
  ADCON0 |= 0x44;

  // set isr priority to 0
  IP1 &= 0x7F;
  IP1H &= 0x7F;

  // enable adc interrupt
  EAD = 1;
}

/***********************************************************************
DESC:    Configures ADC0 and starts conversions
         If trigger = ADC_NONE then ADC0 is configured and no conversions
         are started
RETURNS: Nothing
************************************************************************/
void adc_startadc0conversion
  (
    unsigned char trigger,   // ADC_TIMER, ADC_IMMEDIATE, ADC_EDGE, ADC_DUALIMMEDIATE, ADC_NONE
    unsigned char mode,      // ADC_FIXEDSINGLE    (select one channel in channels)
                             // ADC_FIXEDCONT      (select one channel in channels)
                             // ADC_AUTOSCANSINGLE (select one to four channels in channels)
                             // ADC_AUTOSCANCONT   (select one to four channels in channels)
                             // ADC_DUALCONT       (select two channels in channels)
                             // ADC_SINGLESTEP     (select one to four channels in channels)
    unsigned char channels   // one or more of: ADC0_CHANNEL0, ADC0_CHANNEL1, ADC0_CHANNEL2, ADC0_CHANNEL3
  )
{
  // disable all triggers
  ADCON0 &= 0xDC;
  // clear mode bits and boundary interrupt flag
  ADMODA &= 0xF0;

  switch (mode)
  {
    // fixed channel, single conversion
    case ADC_FIXEDSINGLE:
    // auto scan, single conversion
    case ADC_AUTOSCANSINGLE:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x01;
      break;
    // fixed channel, continuous conversion
    case ADC_FIXEDCONT:
    // dual channel, continuous conversion
    case ADC_DUALCONT:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x02;
        break;
    // auto scan, continuous conversion
    case ADC_AUTOSCANCONT:
      // select channel(s)
      ADINS = channels;
      // select mode
      ADMODA |= 0x04;
      break;
    // single step
    case ADC_SINGLESTEP:
      // select channel(s)
      ADINS = channels;
      break;
  }

  // select new trigger
  switch (trigger)
  {
    // no trigger
    case ADC_NONE:
      break;
    // timer triggered start
    case ADC_TIMER:
      // select trigger
      ADCON0 |= 0x20;
      break;
    // start immedately
    case ADC_IMMEDIATE:
      // select trigger
      ADCON0 |= 0x01;
      break;
    // edge triggered start
    case ADC_EDGE:
      // select trigger
      ADCON0 |= 0x02;
      break;
    // dual start immediately
    case ADC_DUALIMMEDIATE:
      // select trigger
      ADCON0 |= 0x03;
      break;
  }
}

/***********************************************************************
DESC:    Stops ADC0 conversions
RETURNS: Nothing
************************************************************************/
void adc_stopadc0conversion
  (
  void
  )
{
  // disable all triggers
  ADCON0 &= 0xDC;
}

/***********************************************************************
DESC:    ADC Interrupt Service Routine
         Called when an ADC conversion has completed
         Uses register bank 1
RETURNS: Nothing
CAUTION: adc_init must be called first
************************************************************************/
void adc_isr
  (
  void
  ) interrupt 14 using 1
{
  // adc0 conversion complete?
  if (ADCON0 & 0x08)
  {
    // clear ADCI0 flag
    ADCON0 &= ~0x08;
    // read results from AD0DAT0 - AD0DAT3
	newADC0 = AD0DAT0;
	newADC1 = AD0DAT2;
  }
  // adc0 outside boundary range?
  if (ADMODA & 0x08)
  {
    // clear BND0 flag
    ADMODA &= ~0x08;
  }

}