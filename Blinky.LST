C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE BLINKY
OBJECT MODULE PLACED IN Blinky.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Blinky.c OMF2 ROM(COMPACT) OPTIMIZE(7,SPEED) BROWSE MODP2 DEBUG

line level    source

   1          /* Blinky.C - LED Fla+-
   2           sher for the Keil LPC900 EPM Emulator/Programmer Module */
   3          
   4          #include <REG936.H>                     // register definition
   5          #include <LIMITS.H>
   6          #include <INTRINS.H>   
   7          #include <STDIO.H> 
   8          #include <CTYPE.H>
   9          #include "midi_spec.h"
  10          #include "uart.h"
  11          #include "LUTFreq.h"  
  12          #include "LUTsin.h" 
  13          #include "itrip.h"
  14          #include "riff.h"
  15          #include "song.h"
  16          
  17          /******************************* GLOBALS**************************************/
  18          volatile byte xdata sysEx[SYS_LEN];
  19          volatile byte sysIx = 0;
  20          
  21          ///////////all songs....   //drive song selection from here...
  22          
  23          void* code songBook[NUM_SONGS] = {
  24                  silentSong,
  25                  minorSong,
  26                  wholeToneSong,
  27                  beatSong,
  28                  dmbSong
  29          };
  30          
  31          volatile byte songNum = 0; 
  32          volatile word midiClk = 0;
  33          
  34          //state flags -- maybe change to sbit????
  35          volatile byte bdata midiFlags;
  36          sbit AUDIO_L_ON = midiFlags^0;  //(0x01)        //allow wiggling the Laudio (attached to noteOn and sequencer)
  37          sbit TX_VCC_ON = midiFlags^1;   //(0x02)        //allow wiggle the txVCC        (attached to noteOn and sequencer)
  38          sbit STEREO = midiFlags^2;              //(0x04)        //keep track of tx number of channels
  39          sbit PLAYING = midiFlags^3;             //(0x08)        //am I playing now?  //not Ignoring midiClk
  40          sbit BUTT_EN = midiFlags^4;             //(0x10)        //todo test
  41          sbit OMNI = midiFlags^5;                //(0x20)        //todo ?test
  42          sbit SONG_DONE = midiFlags^6;   //0x40
  43          sbit LOOP_SONGS = midiFlags^7;  //instead of naziMidi stop...  just one?  everyone??  deviant!!!
  44          
  45          
  46          //try moving to locals!!!
  47          //#define NUM_RIFFS HEAVY_11_SONG_SIZE//SAUCER_VOLCANO_SONG_SIZE//THUMP1_SONG_SIZE//3//FOR_SONG_ALT_SIZE//
             -FIRST_SONG_ALT_SIZE//THIRD_SONG_SIZE//
  48          volatile RIFF_T* curSong;
  49          volatile word nextRiff = 0;
  50          volatile byte curRiffCnt = 0;
  51          volatile word numRiffs = 0;
  52          volatile byte code* riff;
  53          //deltaSongPos ... just ... cant..  be ...  a ...  byte....
  54          volatile word deltaPos = 0;
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 2   

  55          volatile byte numNotes = 0;
  56          volatile byte nextNote = 0;
  57          
  58          //end exclusive defines
  59          #define SPEED_DIV       1
  60          #define FREQ_START      879
  61                                     
  62          
  63          //timing globals
  64          //REMEMBER!!!  these are up timers... period = 0x0 - values...
  65          //tempo or txVcc pitch
  66          volatile byte periodH0 = 0; 
  67          volatile byte periodL0 = 0;   
  68          volatile byte cnt0 = 0;
  69          volatile byte temp0 = 0;
  70          
  71          //pitch
  72          volatile byte periodH1 = 0; 
  73          volatile byte periodL1 = 0;
  74          
  75          volatile word lDelta = 0;
  76          volatile word txDelta = 0;
  77          volatile bit deltaLUp;
  78          volatile bit deltaTxUp;
  79          
  80          /****************************BH141* instruction*******************************/
  81          
  82          volatile word bdata txState;
  83          sbit stereoTx = txState^3;
  84          sbit phaseMode0 = txState^4;
  85          sbit phaseMode1 = txState^5;
  86          sbit test0 = txState^6;
  87          sbit test1 = txState^7;
  88          
  89          volatile bit txOffSwitch = 0; 
  90          
  91          volatile word station = FREQ_START;
  92          
  93          /***********************************8MAIN????????????????????????*****************/
  94          void main() {   
  95   1      /**************LOCALS****************************/
  96   1              byte i = 0;
  97   1      /**************SETUP++***************************************/
  98   1              setup();
  99   1              txVcc = 0; //on
 100   1              setFreq(station);
 101   1              uart_init();                                                                                     
 102   1              //init first song... just incase its the first one we play
 103   1              //nextRiff = 0; //to be explicit
 104   1              curSong = songBook[songNum];
 105   1              numRiffs = (curSong[nextRiff]).rAddy;  //grab song length!  update will inc nextRiff!!!
 106   1              EA = 1;
 107   1              BUTT_EN = 1;
 108   1      #ifdef COORD
                      TR0 = 0;
                      TR1 = 0;
              //      while (1) {
              //              uart_transmit(CONTROL);
              //              uart_transmit(GENERAL_SLIDER_1_lo);
              //              uart_transmit((i++ << 5) & ~(0x80));
              //              delay(1000);
              //      }
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 3   

                      //makes for a happy synth!!!!
                      delay(50000);
                      uart_transmit(SONG_SELECT);
                      uart_transmit(songNum);
                      delay(50000);
                      for (i = 0; i < 16; i += 2) {
                              uart_transmit(CONTROL+i);
                              uart_transmit(GENERAL_SLIDER_1_lo);
                              uart_transmit(STATION_TO_LO(FREQ_START));
                              delay(1000);
                              uart_transmit(CONTROL+i);
                              uart_transmit(GENERAL_SLIDER_1_hi);
                              uart_transmit(STATION_TO_HI(FREQ_START));
                              delay(1000);
                              uart_transmit(CONTROL+i);
                              uart_transmit(GENERAL_BUTTON_1_on);
                              uart_transmit(127);
                      }
                      LED = 0;
              #else
 137   1              delay(65000);
 138   1              delay(65000);
 139   1              TR1 = 1;
 140   1              TR0 = 1;
 141   1      #endif
 142   1      /****************LOOP*****************************************/
 143   1              for(;;) {
 144   2      #ifdef COORD
                              if (BUTT_EN == 1) {
                                      if (midButt == 0) {  //debounced midButt switches COORD's PLAYING
                                              delay(50000);     //cant functionalize this says the internet...
                                              if (midButt == 0) {
                                                      delay(50000);
                                                      if(midButt == 0) {
                                                              if (PLAYING) { //we are already playing
                                                                      uart_transmit(STOP);
                                                                      PLAYING = 0;
                                                              } else if (midiClk == 0) { //we were playing once
                                                                      curSong = songBook[songNum];
                                                                      nextRiff = 0;
                                                                      deltaPos = 0; //trigger update
                                                                      numRiffs = (curSong[nextRiff]).rAddy;  //grab song length!  dont inc it.. update will
                                                                      uart_transmit(SONG_SELECT);
                                                                      uart_transmit(songNum);
                                                                      uart_transmit(START);
                                                                      PLAYING = 1;
                                                                      curRiffCnt = 0;
                                                                      numNotes = 0;
                                                                      nextNote = 0;
                                                              } else {
                                                                      uart_transmit(CONTINUE);
                                                                      PLAYING = 1;
                                                              }
                                                      }
                                              }
                                              LED = PLAYING;
                                              TR0 = PLAYING;
                                              //TR1 = PLAYING;
                                              delay(50000);
                                      } else if (hiButt == 0) {        //switch to previous song
                                              delay(50000);     //cant functionalize this says the internet...
                                              if (hiButt == 0) {
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 4   

                                                      delay(50000);
                                                      if(hiButt == 0) {
                                                              LED = 1;
                                                              delay(50000);
                                                              if (++songNum >= NUM_SONGS) {    //have we gone past song 0 or 127?
                                                                      songNum = NUM_SONGS-1;
                                                              }
                                                              midiClk = 0;
                                                              PLAYING = 0;
                                                              TR0 = 0;
                                                              //TR1 = 0;
                                                              uart_transmit(STOP);
                                                              uart_transmit(SONG_SELECT);
                                                              uart_transmit(songNum);
                                                              curSong = songBook[songNum];
                                                              nextRiff = 0;
                                                              deltaPos = 0; //trigger update
                                                              numRiffs = (curSong[nextRiff]).rAddy;  //grab song length!  dont inc it.. update will
                                                              curRiffCnt = 0;
                                                              numNotes = 0;
                                                              nextNote = 0;
                                                              LED = 0;
                                                      }
                                              }
                                              delay(50000);
                                      } else if (loButt == 0) {       //switch to previous song
                                              delay(50000);     //cant functionalize this says the internet...
                                              if (loButt == 0) {
                                                      delay(50000);
                                                      if(loButt == 0) {
                                                              LED = 1;
                                                              delay(50000);
                                                              if (--songNum > 127) {  //have we gone past song 0 or 127?
                                                                      songNum = 0;
                                                              }
                                                              midiClk = 0;
                                                              PLAYING = 0;
                                                              TR0 = 0;
                                                              //TR1 = 0;
                                                              uart_transmit(STOP);
                                                              uart_transmit(SONG_SELECT);
                                                              uart_transmit(songNum);
                                                              curSong = songBook[songNum];
                                                              nextRiff = 0;
                                                              deltaPos = 0; //trigger update
                                                              numRiffs = (curSong[nextRiff]).rAddy;  //grab song length!  dont inc it.. update will
                                                              curRiffCnt = 0;
                                                              numNotes = 0;
                                                              nextNote = 0;
                                                              LED = 0;
                                                      }
                                              }
                                              delay(50000);
                                      }
                              }
              
              #else
 236   2              if (curSong != songBook[songNum]) {
 237   3                      curSong = songBook[songNum];
 238   3                      midiClk = 0;
 239   3                      nextRiff = 0;
 240   3                      deltaPos = 0; //trigger update
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 5   

 241   3                      numRiffs = (curSong[nextRiff]).rAddy;  //grab song length!  dont inc it.. update will           
 242   3              } else {
 243   3              //low priority stuff
 244   3              //todo add a flag to loop songs???  fuck midi....
 245   3      #ifdef BASIC_TX
 246   3                      if (midButt == 0) {
 247   4      //                      LED ^= 1;
 248   4                              txVcc ^= 1;
 249   4                              if(txVcc == 1) {
 250   5                                      txOffSwitch = 1;
 251   5                                      LED = 0;
 252   5                              } else {
 253   5                                      txOffSwitch = 0;
 254   5                                      LED = 1;
 255   5                                      setFreq(station);
 256   5                              } 
 257   4                      }                       
 258   3                      delay(UINT_MAX);
 259   3                      if (LED) {
 260   4                              if (hiButt == 0) {
 261   5                                      LED = 0;
 262   5                                      delay(UINT_MAX);
 263   5                                      station++;
 264   5                                      setFreq(station);
 265   5                                      LED = 1;
 266   5                                      delay(UINT_MAX);
 267   5                              } 
 268   4                              else if (loButt == 0) {
 269   5                                      LED = 0;
 270   5                                      delay(UINT_MAX);
 271   5                                      --station;
 272   5                                      setFreq(station);
 273   5                                      LED = 1;
 274   5                                      delay(UINT_MAX);
 275   5                              }
 276   4                              if (station < MIN_FREQ) {
 277   5                                      station = MIN_FREQ;
 278   5                                      LED = 0;
 279   5                                      delay(UINT_MAX);
 280   5                                      LED = 1;
 281   5                                      delay(UINT_MAX);
 282   5                                      LED = 0;
 283   5                                      delay(UINT_MAX);
 284   5                                      LED = 1;
 285   5                                      delay(UINT_MAX);
 286   5                                      LED = 0;
 287   5                                      delay(UINT_MAX);
 288   5                                      LED = 1;
 289   5                                      delay(UINT_MAX);
 290   5                                      LED = 0;
 291   5                                      delay(UINT_MAX);
 292   5                                      LED = 1;
 293   5                                      delay(UINT_MAX);
 294   5                              }
 295   4                              if (station > MAX_FREQ) {
 296   5                                      station = MAX_FREQ;
 297   5                                      LED = 0;
 298   5                                      delay(UINT_MAX);
 299   5                                      LED = 1;
 300   5                                      delay(UINT_MAX);
 301   5                                      LED = 0;
 302   5                                      delay(UINT_MAX);
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 6   

 303   5                                      LED = 1;
 304   5                                      delay(UINT_MAX);
 305   5                                      LED = 0;
 306   5                                      delay(UINT_MAX);
 307   5                                      LED = 1;
 308   5                                      delay(UINT_MAX);
 309   5                                      LED = 0;
 310   5                                      delay(UINT_MAX);
 311   5                                      LED = 1;
 312   5                                      delay(UINT_MAX);
 313   5                              }                                                 
 314   4                      }
 315   3      #endif
 316   3              }
 317   2      #endif
 318   2              }
 319   1      }
 320          /*******************SETUP FUNCTION*********************/
 321          void setup() {
 322   1      
 323   1              P0M1 = 0x07;     //input for buttons and audioN, push pull for audioL
 324   1              P0M2 = 0x08;
 325   1              P1M1 = 0;               //uart_init takes care of TX/RX
 326   1      //      P1M2 |= 0x04;   //configure t0 [p1^2] as push pull
 327   1              P2M1 = 0;               
 328   1              P3M1 = 0;
 329   1              midButt = 1; //pull up resistors on the button inputs
 330   1              hiButt = 1;
 331   1              loButt = 1;
 332   1              LED = 1;        //LED on
 333   1              txVcc = 1;      //transmitter off
 334   1              CE = 0;         //serial input inable for transmitter
 335   1              stereoTx = STEREO;
 336   1              audioL = 0;
 337   1              test0 = 1;      //always
 338   1              test1 = 0;      //always
 339   1              phaseMode0 = 0; //?
 340   1              phaseMode1 = 0; //?
 341   1      
 342   1      #ifdef DAC1_OUT
                      //configure DAC1 out
                        // set dac1 pin to input only (disables digital output)
                      P0M1 |= 0x10;
                      P0M2 &= ~0x10;
                      // init dac1 value to zero
                      AD1DAT3 = 0x00;
                      // enable dac1 output
                      ADMODB |= 0x08;
                      // enable adc1 (also enables dac1)
                      ADCON1 |= 0x04;
              #endif
 354   1      
 355   1                // configure timers
 356   1      
 357   1              TMOD &= 0x00;    //clear conf for timers
 358   1      
 359   1              TAMOD &= 0xEE;   //clear conf for timers
 360   1              TMOD |= 0x11;    //16bit mode for both
 361   1      
 362   1              //TAMOD |= 0x10;
 363   1              periodH1 = 0;
 364   1              periodL1 = 0;
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 7   

 365   1              // timer values                 
 366   1              TH0 = 0;
 367   1              TL0 = 0;
 368   1              
 369   1              TH1 = periodH1;
 370   1              TL1 = periodL1;
 371   1      //#ifdef COORD   //didnt work
 372   1      //      //chain the timers with GPIO toggling
 373   1      //      TMOD |= 0x04;  //set up t0 as a counter
 374   1      //#endif
 375   1              //timer 0 interrupt is higher than timer 1 thus timer 0 is tempo and t1 is pitch
 376   1      #ifdef COORD
                      //set timer0 priority to 2, below tx
                      IP0 &= ~(0x02);
                      IP0H &= ~(0x02);
              #endif
 381   1              // set timer 1 isr priority to 2 and timer 0 to priority 3
 382   1      
 383   1              IP0 &= ~(0x80);
 384   1              IP0H &= ~(0x00);
 385   1              //  // enable timer 1 interrupt
 386   1      
 387   1              ET1 = 1;
 388   1              ET0 = 1;
 389   1      
 390   1              // start timers
 391   1      
 392   1              //TR1 = 1;
 393   1              //TR0 = 1;
 394   1      //      LEDout = 0;
 395   1              //adc_init();
 396   1      }       
 397          /*********************TIMER interrupts****************************/
 398          
 399          void timers_isr1 (void) interrupt 3 using 2
 400          {
 401   1      #ifdef COORD
                              //reload with som const todo
                              //todo explore 8 bit timer mode
              //              TH1 = 0xfe;//periodH1;
                              //TL1 = periodL1;       //is 0xff - the following
              //              TL1 = 0x2e; // we think is close to 256us
                              //TL0++; //didint work....
                              //TL0 = TL0 + 1; //didnt work either...
                              //T0 = 0;
              //              P1^2 ^= 1; //also didnt work in conjunction with count mode...
                              //todo test...
              #else
 413   1                      //reload
 414   1                      TH1 = periodH1; //remember this only counts up!!!!
 415   1                      TL1 = periodL1;
 416   1                      //generate square waves
 417   1                      _nop_(); //matching cycles to t0 rupt
 418   1                      _nop_();
 419   1                      _nop_();
 420   1                      if(AUDIO_L_ON) { //could play with nops here
 421   2                              audioL ^= 1; 
 422   2                      }
 423   1      #endif
 424   1      }
 425          
 426          void timers_isr0 (void) interrupt 1 using 3
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 8   

 427          {
 428   1      #ifdef COORD
                              if (cnt0-- == 0) {
                                      uart_transmit(TIMING_CLOCK);
                                      ++midiClk;
                                      if (deltaPos == 0) {
                                              updateNote();
                                      } else { //parse song
                                              --deltaPos;             
                                      }
                                      cnt0 = temp0;
                                      TH0 = periodH0;
                                      TL0 = periodL0; 
                              } else {
                                      TH0 = 0;
                                      TL0 = 0;
                              }
              #else
 445   1                      //reload
 446   1                      TH0 = periodH0;
 447   1                      TL0 = periodL0;
 448   1                      //generate square waves
 449   1                      if (!txOffSwitch) {
 450   2                              if(TX_VCC_ON) {
 451   3                                      txVcc ^= 1;
 452   3                              } else {
 453   3                                      txVcc = 0; //keep the transmitter ON!!!
 454   3                              }
 455   2                      } else {
 456   2                              txVcc = 1; //tx OFF!  station???
 457   2                      }
 458   1      #endif
 459   1      }
 460          
 461          void updateNote(void) {
 462   1              byte temp, temp2;
 463   1              word thisDelta = 0;
 464   1              bit thisUp = 0, VnotL = 0;;
 465   1      UPDATE_NOTE:
 466   1              if (nextNote >= numNotes) {      //equal to catches init!!!
 467   2                      nextNote = 1; //skip the riff len header
 468   2                      if (curRiffCnt-- == 0) {
 469   3                              if (++nextRiff == numRiffs) { //next riff is newRiff
 470   4                                      //end of SONG!!!!
 471   4                                      PLAYING = 0; //midi says stop
 472   4                                      midiClk = 0;
 473   4                                      LED = 0;
 474   4                                      //going silent for the moment
 475   4                                      AUDIO_L_ON = 0;
 476   4                                      TX_VCC_ON = 0;
 477   4                                      //ensure that we always fall through to this point
 478   4                                      nextRiff = numRiffs - 1;
 479   4                                      curRiffCnt = 0;
 480   4                                      nextNote = numNotes;
 481   4                                      SONG_DONE = 1;
 482   4      #ifdef COORD
                                              uart_transmit(STOP);
                                              TR0 = 0;  //stop playing
                                              //TR1 = 0;      
              #endif
 487   4                              } else {
 488   4                                      riff = (byte*) (curSong[nextRiff]).rAddy;//grab the physical addy of first riff
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 9   

 489   4                                      curRiffCnt = (curSong[nextRiff]).repeats;//grabs number of time riff repeats  
 490   4                                      numNotes = riff[0];                             //grab the length of the riff
 491   4                              }
 492   3                      }
 493   2              }
 494   1              deltaPos = riff[nextNote++];                            //grab deleta T for note
 495   1              temp = (riff[nextNote++]);                              //nextNote is now next note
 496   1      #ifdef COORD
                      //this can likely be very much more optomized!!!!!  todo
                      if (PLAYING) {
                              if (temp & 0x80) {
                                      if (temp < 0xf0) { 
                                              switch (temp & 0xf0) { //find CC and PC and the future todos...
                                              
                                                      case CONTROL:
                                                              
                                                              temp2 = riff[nextNote++]; 
                                                              switch(temp2) { //this could become a big switch!!!
                                                                      
                                                                      case GENERAL_BUTTON_1_on:
                                                                              //delay(900); //didnt help with bad sync on txToggle
                                                                      case GENERAL_SLIDER_1_hi: //todo keep thinking about 14 bit values...
                                                                      case GENERAL_SLIDER_1_lo:
                                                                      default:
                                                                              uart_transmit(temp);
                                                                              uart_transmit(temp2);
                                                                              uart_transmit(riff[nextNote++]);
                                                                      break;
                      
                      //                                              case SOUND_RELEASE_TIME: //todo a sustain structure!
                      //                                              break;
                      
                                                              }
                                                              break;
                                      
                                                      case PROGRAM:
                                                      case PITCH_WHEEL:
                                                      case NOTE_ON:
                                                      case NOTE_OFF:
                                                      case CHAN_PRESSURE:
                                                      case KEY_PRESSURE:
                                                      default:
                                                              break;
                                              }
                                      } else {
                                              switch (temp) {
                                                      case SYSTEM_EXCLUSIVE: // variable length until terminated by an EOX or any status byte
                                                              sysIx = 0;
                                                              //todo in COORD/file sysEx
                                                              //uart_transmit(temp);
                                                      break;
                              
                                              case SONG_POSITION: //beam out the 14-16 bit songPos  LSB first
              //                                              uart_transmit(temp);
              //                                              uart_transmit(riff[nextNote++]);
              //                                              uart_transmit(riff[nextNote++]);
                                                              //todo COORD scan and fix for everybody...
                                                      break;
                              
                                              case SONG_SELECT: //new Song in this Song!!!!! Untested
                                                              curSong = songBook[nextNote]; //nextNote is song number!!!
                                                              uart_transmit(temp);
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 10  

                                                              uart_transmit(riff[nextNote++]);
                                                              midiClk = 0;
                                                              deltaPos = 0;
                                                              nextRiff = 0;
                                                              numRiffs = (curSong[nextRiff]).rAddy;
                                                              curRiffCnt = 0;
                                                              numNotes = 0;
                                                              nextNote = 0;
                                                              PLAYING = 0;
                                                              TR0 = 0;
                                                      break;
                              
                                              case START:      //from the beginning
                                                              midiClk = 0;
                                                              deltaPos = 0;
                                                              nextRiff = 0;
                                                              numRiffs = (curSong[nextRiff]).rAddy;
                                                              curRiffCnt = 0;
                                                              numNotes = 0;
                                                              nextNote = 0;
                                                              uart_transmit(temp);
                                                              PLAYING = 1;
                                                              TR0 = 1;
                                              break;
                              
                                              case STOP:  //this will cease the whole !# till the button is pressed again
                                                              PLAYING = 0;
                                                              uart_transmit(temp);
                                                              TR0 = 0;
                                                              break;
                      
                                              case CONTINUE:
                                                              PLAYING = 1;
                                                              uart_transmit(temp);
                                                              TR0 = 1;
                                                              break;
                                                                       
                                              case SYSTEM_RESET:
                                                              uart_transmit(temp);
                      //                                      AUXR1 |= 0x08; //soft reset, maybe not me...    
                                                      break;
                                                      
                                                      case EOX:                       //also we will find this before the switch!     
                                                      case TIMING_CLOCK: //the thing that should not be
                                                      case TUNE_REQUEST:
                                                      case ACTIVE_SENSING:
                                                      default:
                                                              break;
                                              }
                                      }
                              } else { //we are disastrously misaligned or have 127 values to play with ...
                                      switch (temp & 0x70) {
                                              
                                              case TEMPO_SET: //tempo!!!
                                                      temp0 = (temp & 0x0f); //MSN first
                                                      periodH0 = 0xFF - riff[nextNote++];
                                                      periodL0 = 0xFF - riff[nextNote++];
                                                      cnt0 = 0;
                                                      break;
                                      }
                              }
                              if (deltaPos == 0) {
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 11  

                                      goto UPDATE_NOTE;
                              }
                      }
              #else
 617   1              if (PLAYING) { //todo test switches for cool TX stuff...  
 618   2                      if (temp & 0x80) {
 619   3                              VnotL = 1;
 620   3                      }
 621   2                      temp &= 0x7f;
 622   2                      switch (temp) {
 623   3      
 624   3                              case TX_OFF:
 625   3                                      LED = 0;
 626   3                                      txOffSwitch = 1;        //      TX off
 627   3                              break;
 628   3                              
 629   3                              case TX_ON:
 630   3                                      LED = 1;
 631   3                                      txOffSwitch = 0;        //      TX on
 632   3                              break;
 633   3                              
 634   3                              case UP1:
 635   3                                      thisUp = 1;
 636   3                              case DOWN1:
 637   3                                      thisDelta = 10;
 638   3                              break;
 639   3                              
 640   3                              case UP2:
 641   3                                      thisUp = 1;
 642   3                              case DOWN2:
 643   3                                      thisDelta = 9;
 644   3                              break;
 645   3                              
 646   3                              case UP3:
 647   3                                      thisUp = 1;
 648   3                              case DOWN3:
 649   3                                      thisDelta = 8;
 650   3                              break;
 651   3                              
 652   3                              case UP4:
 653   3                                      thisUp = 1;
 654   3                              case DOWN4:
 655   3                                      thisDelta = 7;
 656   3                              break;
 657   3                              
 658   3                              case UP5:
 659   3                                      thisUp = 1;
 660   3                              case DOWN5:
 661   3                                      thisDelta = 6;
 662   3                              break;
 663   3                      
 664   3                              case UPDOWN_OFF:
 665   3                                      thisDelta = 0;
 666   3                              break;
 667   3                              
 668   3                              case STATION_UP6:
 669   3                                      ++station;
 670   3                              case STATION_UP5:
 671   3                                      ++station;
 672   3                              case STATION_UP4:
 673   3                                      ++station;
 674   3                              case STATION_UP3:
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 12  

 675   3                                      ++station;
 676   3                              case STATION_UP2:
 677   3                                      ++station;
 678   3                              case STATION_UP:
 679   3                                      setFreq(++station);
 680   3                              break;
 681   3                              
 682   3                              case STATION_DOWN6:
 683   3                                      --station;
 684   3                              case STATION_DOWN5:
 685   3                                      --station;
 686   3                              case STATION_DOWN4:
 687   3                                      --station;
 688   3                              case STATION_DOWN3:
 689   3                                      --station;
 690   3                              case STATION_DOWN2:
 691   3                                      --station;
 692   3                              case STATION_DOWN:
 693   3                                      setFreq(--station);
 694   3                              break;
 695   3                              
 696   3                              case HOLD0:
 697   3                              case HOLD1:
 698   3                              case HOLD2:
 699   3                              break;
 700   3      
 701   3                              case NOTE_OFF_MEM:
 702   3                                      if (VnotL == 1) {
 703   4                                              TX_VCC_ON = 0;
 704   4                                      } else {
 705   4                                              AUDIO_L_ON = 0;
 706   4                                      }
 707   3                              break;
 708   3      
 709   3                              default:
 710   3                                      temp -= LUT_MIDI_NOTE_SHIFT;
 711   3                                      if (VnotL == 1) {
 712   4                                              TX_VCC_ON = 1;
 713   4                                              periodH0 = (0xff & (LUTFreq[temp] >> 8));
 714   4                                              periodL0 = (0xff & LUTFreq[temp]);
 715   4                                      } else {
 716   4                                              AUDIO_L_ON = 1;
 717   4                                              periodH1 = (0xff & (LUTFreq[temp] >> 8));
 718   4                                              periodL1 = (0xff & LUTFreq[temp]);
 719   4                                      }
 720   3                              break;
 721   3                      }
 722   2                      if (thisDelta) {
 723   3                              if (VnotL == 1) {        //not OMNIfied!!!! todo
 724   4                                      txDelta = thisDelta;
 725   4                                      deltaTxUp = thisUp;
 726   4                              } else {
 727   4                                      lDelta = thisDelta;
 728   4                                      deltaLUp = thisUp;
 729   4                              }
 730   3                      }
 731   2                      //should just work.... untested...
 732   2                      if (deltaPos == 0) {
 733   3                              goto UPDATE_NOTE;
 734   3                      }
 735   2              }
 736   1      #endif
C51 COMPILER V8.12   BLINKY                                                                08/19/2015 06:51:01 PAGE 13  

 737   1      }
*** WARNING C280 IN LINE 462 OF BLINKY.C: 'temp2': unreferenced local variable
 738          
 739          /*****************TEST SETUP***************************************/
 740          
 741          /********************SETTERS****************************/  
 742          void setFreq (word freq) { //takes
 743   1              if (txOffSwitch || freq > MAX_FREQ || freq < MIN_FREQ) return;  //out of bounds, do-over
 744   1              //if (freq > MAX_FREQ || freq < MIN_FREQ) return;  //out of bounds, do-over
 745   1              else {
 746   2                      word temp = freq;
 747   2                      //EA = 0;               //Disable interrupts for tuning
 748   2                      temp += (txState & 0xF800);  //keep phase cntrl, channels, and test bits
 749   2                      txState = temp;  //return or sorts
 750   2                      txProg();
 751   2                      //EA = 1;               //resume interrupt service
 752   2              }       
 753   1      }
 754          /*********************8CEREAL***************************/
 755          void txProg() { //shift out txState to the transmitter
 756   1              word i = 0x01;
 757   1              bit tempTX = TX_VCC_ON;
 758   1              TX_VCC_ON = 0;
 759   1              txVcc = 0;      //      TX on
 760   1              txClk = 0;   
 761   1              CE = 0;   
 762   1              CE = 1;   
 763   1              for(i = 0x01; i != 0; i <<= 1) {  
 764   2                      txData = txState & i;
 765   2                      txClk = 1;   
 766   2                      txClk = 0;   
 767   2              }       
 768   1              CE = 0;
 769   1              TX_VCC_ON = tempTX; 
 770   1      }
 771          
 772                                                             
 773          void delay (word cnt) { //2.17 us * cnt
 774   1        while (--cnt);
 775   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1345    ----
   CONSTANT SIZE    =    207    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
