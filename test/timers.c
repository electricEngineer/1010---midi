/***********************************************************************
MODULE:    Timers
VERSION:   1.00
CONTAINS:  Routines for controlling the timers on the Philips
           P89LPC936
COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
LICENSE:   May be freely used in commercial and non-commercial code
           without royalties provided this copyright notice remains
           in this file and unaltered
WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
           MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
           TO CHANGE THE CONTENTS OF THIS FILE
GENERATED: On "Oct 11 2010" at "17:21:42" by Code Architect 2.06
***********************************************************************/

// SFR description needs to be included
//#pragma SRC
#include <reg936.h>
#include "itrip.h"
#include "timers.h"

/********external Globals**************************/
//2 byte timer start value...  t = (0xFFFF - start value) * 271 ns + timer0_isr execution time
//extern volatile byte t0High, t0Low;

//buffers and iterators and flags
extern volatile byte inputBuf[BUFFER_LENGTH], inBuf[BUFFER_LENGTH], outBuf[BUFFER_LENGTH];
extern volatile byte inputByte, inByte, outByte, inputBitSmoother, smootherCnt;

extern volatile bit inEmpty, outEmpty, startBit;

volatile bit outStart = 0, outEnd = 0;
volatile byte curBit = 8, outputSmoother = 3, outputByte = BUFFER_LENGTH, outputBit = 8, *output;
/***********************************************************************
DESC:    Initializes timers
         Timer 0 generates an interrupt every ms
         Timer 1 is not used
RETURNS: Nothing
CAUTION: If interrupts are being used then EA must be set to 1
         after calling this function
************************************************************************/
void timers_init
  (
  void
  )
{
  // configure timer 0 and 1
  TMOD &= 0xF0;
  TMOD |= 0x01;
  TAMOD &= 0xFE;

  // initial timer values
  TH0 = t0High;
  TL0 = t0Low;
  
//  TH1 = t1High;
//  TL1 = t1Low;
  // set timer 1 isr priority to highest, t0 below
  IP0 &= 0xFD;
  IP0H &= 0xFD;
  IP0 |= 0x02;
  IP0H |= 0x02;

  // enable timer 0 interrupt
  ET0 = 1;
  // enable timer 1 interrupt
//  ET1 = 1;
//  TR1 = 1;
  // start timer 0	TODO???
  //TR0 = 1;
  inputBuf[inputByte] = inputBuf[inputByte];  //trick assenbler into including inBuf for the interrupt......
  inBuf[inByte] = inBuf[inByte];
  outBuf[outByte] = outBuf[outByte];
  outEmpty = outEmpty;
  output = output;
} // timers_init


/***********************************************************************
DESC:    Timer 0 Interrupt Service Routine
		 executes in 4.4, 4.4, 7 or 4.4, 4.4, 12 us
RETURNS: Nothing
CAUTION: timers_init must be called first
         EA must be set to 1
************************************************************************/
void timers_isr0
  (
  void
  ) interrupt 1 using 3
{
// reinitialize
	TL0 = t0Low;//0xC3;
	TH0 = t0High;//0xff;
	--smootherCnt;
	startBit = 1;
	#pragma ASM
			JB		outEmpty, ONWARD
			DEC		outputSmoother
			MOV		A, outputSmoother
			JNZ		ONWARD
			MOV		outputSmoother, #0x03
			JB		outStart, STARTED
			SETB	audioL
			SETB	outStart
			MOV		R0, outputByte
			MOV		A, #LOW (outBuf - 1)
			ADD		A, R0
			MOV		output, A
			SJMP	ONWARD
		STARTED:
			JB		outEnd, ENDER
			MOV		R0, output 
			MOV		A, @R0
			ADDC	A, ACC
			MOV		@R0, A
			JNC		OUT_0
			CPL		audioL
		OUT_0:	
			DJNZ	outputBit, ONWARD
			MOV		outputBit, #0x08
			DEC		output
			DJNZ	outputByte, ONWARD
			MOV		outputByte, #BUFFER_LENGTH
			SETB 	outEnd
			SJMP	ONWARD
		ENDER:
			CLR		outStart
			CLR		audioL
			CLR		outEnd
			SETB	outEmpty
		ONWARD:
		#pragma ENDASM
	inputBitSmoother += rawInput;
	CMP1 &= ~0x01;
	if (startBit) {
		if (!smootherCnt) {
			smootherCnt = SAMPLES_PER_BIT;
//			inBuf[inByte] <<= 1;
//			inBuf[inByte] += inputBitSmoother & 0x01;
			#pragma ASM
				MOV  	R0, inputByte
				MOV  	A, #LOW (inputBuf - 1)
				ADD  	A, R0
				MOV  	R0, A
				MOV  	A, @R0
				ADD  	A, ACC
				MOV  	@R0, A
				MOV  	A, inputBitSmoother
				ANL  	A, #0x01
				ADD		A, @R0
				MOV		@R0, A
			#pragma ENDASM
			if (--curBit == 0) {
				curBit = 8;
				if (inputByte-- == 0) {
					startBit = 0;
					//inByte = BUFFER_LENGTH;
					inEmpty = 0;
	//				for (inputByte = 0; inputByte < BUFFER_LENGTH; ++inputByte) {
	//					inBuf[inputByte] = inputBuf[inputByte];
	//					inBuf[inputByte] = 0;
	//				}
					#pragma ASM
							MOV		R2, #0x06
							MOV  	R0, #LOW (inputBuf)
							MOV		R1, #LOW (inBuf)
						LOOP:
							MOV  	A,@R0
							MOV  	@R1,A
							MOV		@R0, #0x00
							INC		R0
							INC		R1
							DJNZ 	R2, LOOP
							MOV		inputByte, #BUFFER_LENGTH
					#pragma ENDASM
				}
			}	
		inputBitSmoother = 0;
		}		
	} else {
		if (!smootherCnt) {
			smootherCnt = SAMPLES_PER_BIT;
	 		if (inputBitSmoother == 4) {
				startBit = 1;
			}
		inputBitSmoother <<= 1;
		}
	}
} // timers_isr0


//void timers_isr1
//  (
//  void
//  ) interrupt 3 using 3
//{
//// reinitialize
//	#pragma ASM
//			PUSH 	ACC
//			PUSH 	PSW
//			MOV 	TH1, #t1High
//			MOV 	TL1, #t1Low
//			JB		outEmpty, ONWARD
//			JB		outStart, STARTED
//			SETB	audioL
//			SETB	outStart
//			MOV		R0, outByte
//			MOV		A, #LOW (outBuf - 1)
//			ADD		A, R0
//			MOV		output, A
//			SJMP	ONWARD
//		STARTED:
//			JB		outEnd, ENDER
//			MOV		R0, output 
//			MOV		A, @R0
//			ADDC	A, ACC
//			MOV		@R0, A
//			JNC		OUT_0
//			CPL		audioL
//		OUT_0:	
//			DJNZ	outputBit, ONWARD
//			MOV		outputBit, #0x08
//			DEC		output
//			DJNZ	outByte, ONWARD
//			MOV		outByte, #BUFFER_LENGTH
//			SETB 	outEnd
//			SJMP	ONWARD
//		ENDER:
//			CLR		outStart
//			CLR		audioL
//			CLR		outEnd
//			SETB	outEmpty
//		ONWARD:
//			POP 	ACC
//			POP 	PSW
//		#pragma ENDASM
//}

/***********************************************************************
DESC:    Starts timer 0
RETURNS: Nothing
CAUTION: timers_init must be called first
************************************************************************/
void timers_starttimer0
  (
  void
  )
{
  TR0 = 1;
} // timers_starttimer0

/***********************************************************************
DESC:    Stops timer 0
RETURNS: Nothing
CAUTION: timers_init must be called first
************************************************************************/
void timers_stoptimer0
  (
  void
  )
{
  TR0 = 0;
} // timers_stoptimer0


