C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE TIMERS
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE test\timers.c ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBO
                    -LS PRINT(.\lst\timers.lst) PREPRINT(.\lst\timers.i) SRC(.\obj\timers.SRC)

line level    source

   1          /***********************************************************************
   2          MODULE:    Timers
   3          VERSION:   1.00
   4          CONTAINS:  Routines for controlling the timers on the Philips
   5                     P89LPC936
   6          COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
   7          LICENSE:   May be freely used in commercial and non-commercial code
   8                     without royalties provided this copyright notice remains
   9                     in this file and unaltered
  10          WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
  11                     MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
  12                     TO CHANGE THE CONTENTS OF THIS FILE
  13          GENERATED: On "Oct 11 2010" at "17:21:42" by Code Architect 2.06
  14          ***********************************************************************/
  15          
  16          // SFR description needs to be included
  17          //#pragma SRC
  18          #include <reg936.h>
   1      =1  /*--------------------------------------------------------------------------
   2      =1  REG936.H
   3      =1  
   4      =1  Header file for Philips 89LPC936
   5      =1  Copyright (c) 1988-2006 KEIL - An ARM Company
   6      =1  All rights reserved.
   7      =1  V1.1
   8      =1  --------------------------------------------------------------------------*/
   9      =1  
  10      =1  #ifndef __REG936_H__
  11      =1  #define __REG936_H__
  12      =1  
  13      =1  /*  BYTE Registers  */
  14      =1  sfr P0   = 0x80;
  15      =1  sfr P1   = 0x90;
  16      =1  sfr P2   = 0xA0;
  17      =1  sfr P3   = 0xB0;
  18      =1  sfr PSW  = 0xD0;
  19      =1  sfr ACC  = 0xE0;
  20      =1  sfr B    = 0xF0;
  21      =1  sfr SP   = 0x81;
  22      =1  sfr DPL  = 0x82;
  23      =1  sfr DPH  = 0x83;
  24      =1  sfr PCON = 0x87;
  25      =1  sfr TCON = 0x88;
  26      =1  sfr TMOD = 0x89;
  27      =1  sfr TL0  = 0x8A;
  28      =1  sfr TL1  = 0x8B;
  29      =1  sfr TH0  = 0x8C;
  30      =1  sfr TH1  = 0x8D;
  31      =1  sfr IEN0 = 0xA8;
  32      =1  sfr IP0  = 0xB8;
  33      =1  sfr SCON = 0x98;
  34      =1  sfr SBUF = 0x99;
  35      =1  
  36      =1  sfr ADCON0 = 0x8E;
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 2   

  37      =1  sfr ADCON1 = 0x97;
  38      =1  sfr ADMODA = 0xC0;
  39      =1  sfr ADMODB = 0xA1;
  40      =1  sfr ADINS  = 0xA3;
  41      =1  sfr AD0DAT0= 0xC5;
  42      =1  sfr AD0DAT1= 0xC6;
  43      =1  sfr AD0DAT2= 0xC7;
  44      =1  sfr AD0DAT3= 0xF4;
  45      =1  sfr AD1DAT0= 0xD5;
  46      =1  sfr AD1DAT1= 0xD6;
  47      =1  sfr AD1DAT2= 0xD7;
  48      =1  sfr AD1DAT3= 0xF5;
  49      =1  sfr AD0BH  = 0xBB;
  50      =1  sfr AD0BL  = 0xA6;
  51      =1  sfr AD1BH  = 0xC4;
  52      =1  sfr AD1BL  = 0xBC;
  53      =1  sfr AUXR1  = 0xA2;
  54      =1  sfr SADDR  = 0xA9;
  55      =1  sfr SADEN  = 0xB9;
  56      =1  sfr TL2    = 0xCC;
  57      =1  sfr TH2    = 0xCD;
  58      =1  sfr BRGR0  = 0xBE;
  59      =1  sfr BRGR1  = 0xBF;
  60      =1  sfr BRGCON = 0xBD;
  61      =1  sfr CCCRA  = 0xEA;
  62      =1  sfr CCCRB  = 0xEB;
  63      =1  sfr CCCRC  = 0xEC;
  64      =1  sfr CCCRD  = 0xED;
  65      =1  sfr CMP1   = 0xAC;
  66      =1  sfr CMP2   = 0xAD;
  67      =1  sfr DEECON = 0xF1;
  68      =1  sfr DEEDAT = 0xF2;
  69      =1  sfr DEEADR = 0xF3;
  70      =1  sfr DIVM   = 0x95;
  71      =1  sfr I2ADR  = 0xDB;
  72      =1  sfr I2CON  = 0xD8;
  73      =1  sfr I2DAT  = 0xDA;
  74      =1  sfr I2SCLH = 0xDD;
  75      =1  sfr I2SCLL = 0xDC;
  76      =1  sfr I2STAT = 0xD9;
  77      =1  sfr ICRAH  = 0xAB;
  78      =1  sfr ICRAL  = 0xAA;
  79      =1  sfr ICRBH  = 0xAF;
  80      =1  sfr ICRBL  = 0xAE;
  81      =1  sfr IEN1   = 0xE8;
  82      =1  sfr IP1    = 0xF8;
  83      =1  sfr IP1H   = 0xF7;
  84      =1  sfr KBCON  = 0x94;
  85      =1  sfr KBMASK = 0x86;
  86      =1  sfr KBPATN = 0x93;
  87      =1  sfr OCRAH  = 0xEF;
  88      =1  sfr OCRAL  = 0xEE;
  89      =1  sfr OCRBH  = 0xFB;
  90      =1  sfr OCRBL  = 0xFA;
  91      =1  sfr OCRCH  = 0xFD;
  92      =1  sfr OCRCL  = 0xFC;
  93      =1  sfr OCRDH  = 0xFF;
  94      =1  sfr OCRDL  = 0xFE;
  95      =1  sfr P0M1   = 0x84;
  96      =1  sfr P0M2   = 0x85;
  97      =1  sfr P1M1   = 0x91;
  98      =1  sfr P1M2   = 0x92;
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 3   

  99      =1  sfr P2M1   = 0xA4;
 100      =1  sfr P2M2   = 0xA5;
 101      =1  sfr P3M1   = 0xB1;
 102      =1  sfr P3M2   = 0xB2;
 103      =1  sfr PCONA  = 0xB5;
 104      =1  sfr PT0AD  = 0xF6;
 105      =1  sfr RSTSRC = 0xDF;
 106      =1  sfr RTCCON = 0xD1;
 107      =1  sfr RTCH   = 0xD2;
 108      =1  sfr RTCL   = 0xD3;
 109      =1  sfr SSTAT  = 0xBA;
 110      =1  sfr SPCTL  = 0xE2;
 111      =1  sfr SPSTAT = 0xE1;
 112      =1  sfr SPDAT  = 0xE3;
 113      =1  sfr TAMOD  = 0x8F;
 114      =1  sfr TCR20  = 0xC8;
 115      =1  sfr TCR21  = 0xF9;
 116      =1  sfr TICR2  = 0xC9;
 117      =1  sfr TIFR2  = 0xE9;
 118      =1  sfr TISE2  = 0xDE;
 119      =1  sfr TOR2H  = 0xCF;
 120      =1  sfr TOR2L  = 0xCE;
 121      =1  sfr TPCR2H = 0xCB;
 122      =1  sfr TPCR2L = 0xCA;
 123      =1  sfr TRIM   = 0x96;
 124      =1  sfr WDCON  = 0xA7;
 125      =1  sfr WDL    = 0xC1;
 126      =1  sfr WFEED1 = 0xC2;
 127      =1  sfr WFEED2 = 0xC3;
 128      =1  sfr IP0H   = 0xB7;
 129      =1  
 130      =1  /*  BIT Registers  */
 131      =1  /*  PSW   */
 132      =1  sbit CY   = PSW^7;
 133      =1  sbit AC   = PSW^6;
 134      =1  sbit F0   = PSW^5;
 135      =1  sbit RS1  = PSW^4;
 136      =1  sbit RS0  = PSW^3;
 137      =1  sbit OV   = PSW^2;
 138      =1  sbit F1   = PSW^1;
 139      =1  sbit P    = PSW^0;
 140      =1  
 141      =1  /*  TCON  */
 142      =1  sbit TF1  = TCON^7;
 143      =1  sbit TR1  = TCON^6;
 144      =1  sbit TF0  = TCON^5;
 145      =1  sbit TR0  = TCON^4;
 146      =1  sbit IE1  = TCON^3;
 147      =1  sbit IT1  = TCON^2;
 148      =1  sbit IE0  = TCON^1;
 149      =1  sbit IT0  = TCON^0;
 150      =1  
 151      =1  /*  IEN0   */
 152      =1  sbit EA   = IEN0^7;
 153      =1  sbit EWDRT = IEN0^6;
 154      =1  sbit EBO   = IEN0^5;
 155      =1  sbit ES   = IEN0^4; // alternatively "ESR"
 156      =1  sbit ESR  = IEN0^4;
 157      =1  sbit ET1  = IEN0^3;
 158      =1  sbit EX1  = IEN0^2;
 159      =1  sbit ET0  = IEN0^1;
 160      =1  sbit EX0  = IEN0^0;
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 4   

 161      =1  
 162      =1  /*  IEN1   */
 163      =1  sbit EAD  = IEN1^7; // alternatively "EIEE" 
 164      =1  sbit EIEE = IEN1^7;
 165      =1  sbit EST  = IEN1^6;
 166      =1  sbit ECCU = IEN1^4;
 167      =1  sbit ESPI = IEN1^3;
 168      =1  sbit EC   = IEN1^2;
 169      =1  sbit EKBI = IEN1^1;
 170      =1  sbit EI2C = IEN1^0;
 171      =1  
 172      =1  /*  IP0   */ 
 173      =1  sbit PWDRT = IP0^6;
 174      =1  sbit PB0   = IP0^5;
 175      =1  sbit PS    = IP0^4; // alternatively "PSR"
 176      =1  sbit PSR   = IP0^4;
 177      =1  sbit PT1   = IP0^3;
 178      =1  sbit PX1   = IP0^2;
 179      =1  sbit PT0   = IP0^1;
 180      =1  sbit PX0   = IP0^0;
 181      =1  
 182      =1  /*  IP1   */
 183      =1  sbit PAD  = IP1^7; // alternatively "PIEE" 
 184      =1  sbit PIEE = IP1^7;
 185      =1  sbit PST  = IP1^6;
 186      =1  sbit PCCU = IP1^4;
 187      =1  sbit PSPI = IP1^3;
 188      =1  sbit PC_  = IP1^2;
 189      =1  sbit PKBI = IP1^1;
 190      =1  sbit PI2C = IP1^0;
 191      =1  
 192      =1  /*  SCON  */
 193      =1  sbit SM0  = SCON^7; // alternatively "FE"
 194      =1  sbit FE   = SCON^7;
 195      =1  sbit SM1  = SCON^6;
 196      =1  sbit SM2  = SCON^5;
 197      =1  sbit REN  = SCON^4;
 198      =1  sbit TB8  = SCON^3;
 199      =1  sbit RB8  = SCON^2;
 200      =1  sbit TI   = SCON^1;
 201      =1  sbit RI   = SCON^0;
 202      =1  
 203      =1  /*  I2CON  */
 204      =1  sbit I2EN  = I2CON^6;
 205      =1  sbit STA   = I2CON^5;
 206      =1  sbit STO   = I2CON^4;
 207      =1  sbit SI    = I2CON^3;
 208      =1  sbit AA    = I2CON^2;
 209      =1  sbit CRSEL = I2CON^0;
 210      =1  
 211      =1  /*  P0  */
 212      =1  sbit KB7 = P0^7; // alternatively "T1"
 213      =1  sbit T1 = P0^7;
 214      =1  sbit KB6 = P0^6; // alternatively "CMP1"
 215      =1  //sbit CMP1 = P0^6;
 216      =1  sbit KB5 = P0^5;
 217      =1  sbit KB4 = P0^4;
 218      =1  sbit KB3 = P0^3;
 219      =1  sbit KB2 = P0^2;
 220      =1  sbit KB1 = P0^1;
 221      =1  sbit KB0 = P0^0; // alternatively "CMP2"
 222      =1  //sbit CMP2 = P0^0;
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 5   

 223      =1  
 224      =1  /*  P1  */
 225      =1  sbit OCC     = P1^7;
 226      =1  sbit OCB     = P1^6;
 227      =1  sbit RST     = P1^5;
 228      =1  sbit INT1    = P1^4;
 229      =1  sbit INT0    = P1^3; // alternatively "SDA"
 230      =1  sbit SDA     = P1^3;
 231      =1  sbit T0      = P1^2; // alternatively "SCL"
 232      =1  sbit SCL     = P1^2;
 233      =1  sbit RxD     = P1^1;
 234      =1  sbit TxD     = P1^0;
 235      =1  
 236      =1  /*  P2  */
 237      =1  sbit ICA     = P2^7;
 238      =1  sbit OCA     = P2^6;
 239      =1  sbit SPICLK  = P2^5;
 240      =1  sbit SS      = P2^4;
 241      =1  sbit MISO    = P2^3;
 242      =1  sbit MOSI    = P2^2;
 243      =1  sbit OCD     = P2^1;
 244      =1  sbit ICB     = P2^0;
 245      =1  
 246      =1  /*  P3  */
 247      =1  sbit XTAL1= P3^1;
 248      =1  sbit XTAL2= P3^0;
 249      =1  
 250      =1  /* TCR20 */
 251      =1  sbit PLLEN = TCR20^7;
 252      =1  sbit HLTRN = TCR20^6;
 253      =1  sbit HLTEN = TCR20^5;
 254      =1  sbit ALTCD = TCR20^4;
 255      =1  sbit ALTAB = TCR20^3;
 256      =1  sbit TDIR2 = TCR20^2;
 257      =1  sbit TMOD21= TCR20^1;
 258      =1  sbit TMOD20= TCR20^0;
 259      =1  
 260      =1  /* ADMODA */
 261      =1  sbit BNDI1  = ADMODA^7;
 262      =1  sbit BURST1 = ADMODA^6;
 263      =1  sbit SCC1   = ADMODA^5;
 264      =1  sbit SCAN1  = ADMODA^4;
 265      =1  sbit BNDI0  = ADMODA^3;
 266      =1  sbit BURST0 = ADMODA^2;
 267      =1  sbit SCC0   = ADMODA^1;
 268      =1  sbit SCAN0  = ADMODA^0;
 269      =1  
 270      =1  #endif
 271      =1  
  19          #include "itrip.h"
   1      =1  /*
   2      =1  itrip HEADERZ v1e-9
   3      =1  */
   4      =1  
   5      =1  #ifndef ITRIP_H
   6      =1  #define ITRIP_H 
   7      =1  /**************************GLOBALS*******************************************/
   8      =1  typedef unsigned char byte;
   9      =1  typedef unsigned int word;
  10      =1  
  11      =1  #define MAX_FREQ        1080
  12      =1  #define MIN_FREQ        700
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 6   

  13      =1  
  14      =1  #define BARKER_7                0x58    //01011000
  15      =1  #define NOT_BARKER_7    0xA7    //10100111
  16      =1  
  17      =1  #define fineStruct 1
  18      =1  #define BUFFER_LENGTH   0x06
  19      =1  #define MAX_FRAME 0x08
  20      =1  #define DATABYTES_PER_FRAME 0x02
  21      =1  #define SAMPLES_PER_BIT 0x03
  22      =1  #define t0High  0xFF
  23      =1  #define t0Low   0x96
  24      =1  //#define       t1High  0xFF
  25      =1  //#define t1Low         0x3C
  26      =1  /*******************************EMPerical numbers
  27      =1  11.8.10
  28      =1  50 -> 416 HZ
  29      =1  5 - >31.25 kHz
  30      =1  
  31      =1  11.22.10
  32      =1  30 -> 25k  nothing else....
  33      =1  *******************************************************************************/
  34      =1  #define NORM_T
  35      =1  //#define SHOW_T
  36      =1  //#define SYNTH_T
  37      =1  //#define LEAVE_T
  38      =1  //#define DELEAVE_T
  39      =1  //#define CODE_T
  40      =1  
  41      =1  //#define ADC_T_SOFT
  42      =1  //#define ADC_DELAY  10000
  43      =1  
  44      =1  //#def4-ADC_T_HARD               
  45      =1  #define ADC_ARRAY_L 16  
  46      =1  
  47      =1  //#define COM_T
  48      =1  #define rawInput                (CMP1 & 0x01)   //P0^4 is comp1 input from radio through 1 uF
  49      =1  //#define CCU_MIN_CYCLE 164     //<100 Hz
  50      =1  //#define CCU_MIN_GOOD  521     //<15 Hz
  51      =1  //#define CCU_DC                        8192    //<1 Hz
  52      =1  //#define CCU_MAX_BAD           25              //max number of fast cycles ~.5 sec
  53      =1  
  54      =1  //#define MIN_GOOD_HALF_CYCLES  12 //~1 sec
  55      =1  //#define MAX_TUNING_TRIES              381 
  56      =1  //#define POW_T 
  57      =1  
  58      =1  //#define OSC_T 
  59      =1  
  60      =1  /****************************PROTOS*********************/
  61      =1          void setup ();  //name and turn on
  62      =1          void delay (word cnt);
  63      =1          void shiftout8 (byte d);
  64      =1  //      void shiftout16 (word d);
  65      =1  //      void shiftout32 (word dh, word dl);
  66      =1          void txProg ();
  67      =1          void setFreq (word freq);
  68      =1  //      void copyInputToIn ();
  69      =1          void copyInterToData (byte dest[], byte source[]);
  70      =1          void copyDataToInter (byte dest[], byte source[]);
  71      =1  /************************EMPTY Protos****************/  
  72      =1  //      void txStero ();
  73      =1  //      void txMono ();
  74      =1  //      
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 7   

  75      =1  //      void incFreq ();
  76      =1  //      void decFreq ();
  77      =1  //      void setChan (byte numChan);
  78      =1          
  79      =1  /*******************deinterleaver*********************
  80      =1  DESC:           Loads interbuf with sequenced data from inBuf....
  81      =1  
  82      =1  RETURNS:        Nothing.
  83      =1  
  84      =1  CAUTION:        inBuf must be full and interByte, inByte must 
  85      =1                          = 8 and interBuf must be zeros  
  86      =1  
  87      =1  299 - 366 us execution
  88      =1  *******************************************************/        
  89      =1          void deInterleave ();
  90      =1          void deleaveBits ();
  91      =1  //      void testDI();
  92      =1  /*************************************8
  93      =1  inBuf must be empty and inter / inByte must = 8
  94      =1  and interBuf must hold sequenced data
  95      =1  loads inBuf with interleaved data...
  96      =1  
  97      =1  340  - 375 us
  98      =1  ************************************/
  99      =1          void interleave ();
 100      =1          void leaveBits ();
 101      =1  //      void testI (byte vect);
 102      =1  //      void testEncode(byte cnt);
 103      =1  /********************ENCODE********************************8
 104      =1  dEmpty must be 0 and interByte = 8
 105      =1  wrapper for assembly function which generates 24 bit parity
 106      =1  for 24 bit of data....
 107      =1  
 108      =1  15 us execution
 109      =1  *********************************************************/
 110      =1          void encode();
 111      =1          void encode_ASM ();
 112      =1          
 113      =1          void decode ();
 114      =1          void decode_ASM();
 115      =1  
 116      =1          void testTXRX (byte error, byte vect);
 117      =1  
 118      =1  /*******************************************************
 119      =1  DESC:    Autotuning algorithm detects low frequency audio 
 120      =1                   feedback characteristic of a good TX to RX lock.
 121      =1  RETURNS: The frequency of the Rx on the input 
 122      =1                  (0x0000 indicates a failure, 0x01 indicates DC / no input on pin) 
 123      =1  CAUTION: The RX must be able to swing the output audio
 124      =1                   greater than 1.24V and produce a frequency of 
 125      =1                   feedback <15Hz. (Headphone outs work)
 126      =1  *********************************************************/
 127      =1  //      word autotune ();
 128      =1          
 129      =1          void CRCCheck (byte *MSB);
 130      =1          void CRCGen     (byte *MSB);
 131      =1          void CRC_ASM();
 132      =1  
 133      =1  /******************PIN NAMES****************************/       
 134      =1          sbit txVcc = P2^7;
 135      =1          sbit txData = P2^2;
 136      =1          sbit txClk = P2^3;
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 8   

 137      =1          sbit LED = P2^5;
 138      =1          sbit CE = P2^4;
 139      =1          sbit midButt = P0^0;
 140      =1          sbit hiButt = P0^1;
 141      =1          sbit loButt = P0^2;
 142      =1          sbit audioL = P0^3;
 143      =1          sbit audioN = P0^4;     //must be soldered and AC coupled (DC blocked) with 1 uF
 144      =1          sbit ccTimer = P2^0;
 145      =1  #endif
  20          #include "timers.h"
   1      =1  /***********************************************************************
   2      =1  MODULE:    Timers
   3      =1  VERSION:   1.00
   4      =1  CONTAINS:  Routines for controlling the timers on the Philips
   5      =1             P89LPC936
   6      =1  COPYRIGHT: Embedded Systems Academy, Inc. - www.esacademy.com
   7      =1  LICENSE:   May be freely used in commercial and non-commercial code
   8      =1             without royalties provided this copyright notice remains
   9      =1             in this file and unaltered
  10      =1  WARNING:   IF THIS FILE IS REGENERATED BY CODE ARCHITECT ANY CHANGES
  11      =1             MADE WILL BE LOST. WHERE POSSIBLE USE ONLY CODE ARCHITECT
  12      =1             TO CHANGE THE CONTENTS OF THIS FILE
  13      =1  GENERATED: On "Oct 11 2010" at "17:21:42" by Code Architect 2.06
  14      =1  ***********************************************************************/
  15      =1  
  16      =1  #ifndef _TIMERSH_
  17      =1  #define _TIMERSH_
  18      =1  
  19      =1  /***********************************************************************
  20      =1  DESC:    Initializes timers
  21      =1           Timer 0 generates an interrupt every 10ms
  22      =1           Timer 1 is not used
  23      =1  RETURNS: Nothing
  24      =1  CAUTION: If interrupts are being used then EA must be set to 1
  25      =1           after calling this function
  26      =1  ************************************************************************/
  27      =1  void timers_init
  28      =1    (
  29      =1    void
  30      =1    );
  31      =1  
  32      =1  /***********************************************************************
  33      =1  DESC:    Starts timer 0
  34      =1  RETURNS: Nothing
  35      =1  CAUTION: timers_init must be called first
  36      =1  ************************************************************************/
  37      =1  void timers_starttimer0
  38      =1    (
  39      =1    void
  40      =1    );
  41      =1  
  42      =1  /***********************************************************************
  43      =1  DESC:    Stops timer 0
  44      =1  RETURNS: Nothing
  45      =1  CAUTION: timers_init must be called first
  46      =1  ************************************************************************/
  47      =1  void timers_stoptimer0
  48      =1    (
  49      =1    void
  50      =1    );
  51      =1  
  52      =1  #endif // _TIMERSH_
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 9   

  53      =1  
  54      =1  
  55      =1  
  21          
  22          /********external Globals**************************/
  23          //2 byte timer start value...  t = (0xFFFF - start value) * 271 ns + timer0_isr execution time
  24          //extern volatile byte t0High, t0Low;
  25          
  26          //buffers and iterators and flags
  27          extern volatile byte inputBuf[BUFFER_LENGTH], inBuf[BUFFER_LENGTH], outBuf[BUFFER_LENGTH];
  28          extern volatile byte inputByte, inByte, outByte, inputBitSmoother, smootherCnt;
  29          
  30          extern volatile bit inEmpty, outEmpty, startBit;
  31          
  32          volatile bit outStart = 0, outEnd = 0;
  33          volatile byte curBit = 8, outputSmoother = 3, outputByte = BUFFER_LENGTH, outputBit = 8, *output;
  34          /***********************************************************************
  35          DESC:    Initializes timers
  36                   Timer 0 generates an interrupt every ms
  37                   Timer 1 is not used
  38          RETURNS: Nothing
  39          CAUTION: If interrupts are being used then EA must be set to 1
  40                   after calling this function
  41          ************************************************************************/
  42          void timers_init
  43            (
  44            void
  45            )
  46          {
  47   1        // configure timer 0 and 1
  48   1        TMOD &= 0xF0;
  49   1        TMOD |= 0x01;
  50   1        TAMOD &= 0xFE;
  51   1      
  52   1        // initial timer values
  53   1        TH0 = t0High;
  54   1        TL0 = t0Low;
  55   1        
  56   1      //  TH1 = t1High;
  57   1      //  TL1 = t1Low;
  58   1        // set timer 1 isr priority to highest, t0 below
  59   1        IP0 &= 0xFD;
  60   1        IP0H &= 0xFD;
  61   1        IP0 |= 0x02;
  62   1        IP0H |= 0x02;
  63   1      
  64   1        // enable timer 0 interrupt
  65   1        ET0 = 1;
  66   1        // enable timer 1 interrupt
  67   1      //  ET1 = 1;
  68   1      //  TR1 = 1;
  69   1        // start timer 0      TODO???
  70   1        //TR0 = 1;
  71   1        inputBuf[inputByte] = inputBuf[inputByte];  //trick assenbler into including inBuf for the interrupt....
             -..
  72   1        inBuf[inByte] = inBuf[inByte];
  73   1        outBuf[outByte] = outBuf[outByte];
  74   1        outEmpty = outEmpty;
  75   1        output = output;
  76   1      } // timers_init
  77          
  78          
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 10  

  79          /***********************************************************************
  80          DESC:    Timer 0 Interrupt Service Routine
  81                           executes in 4.4, 4.4, 7 or 4.4, 4.4, 12 us
  82          RETURNS: Nothing
  83          CAUTION: timers_init must be called first
  84                   EA must be set to 1
  85          ************************************************************************/
  86          void timers_isr0
  87            (
  88            void
  89            ) interrupt 1 using 3
  90          {
  91   1      // reinitialize
  92   1              TL0 = t0Low;//0xC3;
  93   1              TH0 = t0High;//0xff;
  94   1              --smootherCnt;
  95   1              startBit = 1;
  96   1              #pragma ASM
  97   1                              JB              outEmpty, ONWARD
  98   1                              DEC             outputSmoother
  99   1                              MOV             A, outputSmoother
 100   1                              JNZ             ONWARD
 101   1                              MOV             outputSmoother, #0x03
 102   1                              JB              outStart, STARTED
 103   1                              SETB    audioL
 104   1                              SETB    outStart
 105   1                              MOV             R0, outputByte
 106   1                              MOV             A, #LOW (outBuf - 1)
 107   1                              ADD             A, R0
 108   1                              MOV             output, A
 109   1                              SJMP    ONWARD
 110   1                      STARTED:
 111   1                              JB              outEnd, ENDER
 112   1                              MOV             R0, output 
 113   1                              MOV             A, @R0
 114   1                              ADDC    A, ACC
 115   1                              MOV             @R0, A
 116   1                              JNC             OUT_0
 117   1                              CPL             audioL
 118   1                      OUT_0:  
 119   1                              DJNZ    outputBit, ONWARD
 120   1                              MOV             outputBit, #0x08
 121   1                              DEC             output
 122   1                              DJNZ    outputByte, ONWARD
 123   1                              MOV             outputByte, #BUFFER_LENGTH
 124   1                              SETB    outEnd
 125   1                              SJMP    ONWARD
 126   1                      ENDER:
 127   1                              CLR             outStart
 128   1                              CLR             audioL
 129   1                              CLR             outEnd
 130   1                              SETB    outEmpty
 131   1                      ONWARD:
 132   1                      #pragma ENDASM
 133   1              inputBitSmoother += rawInput;
 134   1              CMP1 &= ~0x01;
 135   1              if (startBit) {
 136   2                      if (!smootherCnt) {
 137   3                              smootherCnt = SAMPLES_PER_BIT;
 138   3      //                      inBuf[inByte] <<= 1;
 139   3      //                      inBuf[inByte] += inputBitSmoother & 0x01;
 140   3                              #pragma ASM
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 11  

 141   3                                      MOV     R0, inputByte
 142   3                                      MOV     A, #LOW (inputBuf - 1)
 143   3                                      ADD     A, R0
 144   3                                      MOV     R0, A
 145   3                                      MOV     A, @R0
 146   3                                      ADD     A, ACC
 147   3                                      MOV     @R0, A
 148   3                                      MOV     A, inputBitSmoother
 149   3                                      ANL     A, #0x01
 150   3                                      ADD             A, @R0
 151   3                                      MOV             @R0, A
 152   3                              #pragma ENDASM
 153   3                              if (--curBit == 0) {
 154   4                                      curBit = 8;
 155   4                                      if (inputByte-- == 0) {
 156   5                                              startBit = 0;
 157   5                                              //inByte = BUFFER_LENGTH;
 158   5                                              inEmpty = 0;
 159   5              //                              for (inputByte = 0; inputByte < BUFFER_LENGTH; ++inputByte) {
 160   5              //                                      inBuf[inputByte] = inputBuf[inputByte];
 161   5              //                                      inBuf[inputByte] = 0;
 162   5              //                              }
 163   5                                              #pragma ASM
 164   5                                                              MOV             R2, #0x06
 165   5                                                              MOV     R0, #LOW (inputBuf)
 166   5                                                              MOV             R1, #LOW (inBuf)
 167   5                                                      LOOP:
 168   5                                                              MOV     A,@R0
 169   5                                                              MOV     @R1,A
 170   5                                                              MOV             @R0, #0x00
 171   5                                                              INC             R0
 172   5                                                              INC             R1
 173   5                                                              DJNZ    R2, LOOP
 174   5                                                              MOV             inputByte, #BUFFER_LENGTH
 175   5                                              #pragma ENDASM
 176   5                                      }
 177   4                              }       
 178   3                      inputBitSmoother = 0;
 179   3                      }               
 180   2              } else {
 181   2                      if (!smootherCnt) {
 182   3                              smootherCnt = SAMPLES_PER_BIT;
 183   3                              if (inputBitSmoother == 4) {
 184   4                                      startBit = 1;
 185   4                              }
 186   3                      inputBitSmoother <<= 1;
 187   3                      }
 188   2              }
 189   1      } // timers_isr0
 190          
 191          
 192          //void timers_isr1
 193          //  (
 194          //  void
 195          //  ) interrupt 3 using 3
 196          //{
 197          //// reinitialize
 198          //      #pragma ASM
 199          //                      PUSH    ACC
 200          //                      PUSH    PSW
 201          //                      MOV     TH1, #t1High
 202          //                      MOV     TL1, #t1Low
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 12  

 203          //                      JB              outEmpty, ONWARD
 204          //                      JB              outStart, STARTED
 205          //                      SETB    audioL
 206          //                      SETB    outStart
 207          //                      MOV             R0, outByte
 208          //                      MOV             A, #LOW (outBuf - 1)
 209          //                      ADD             A, R0
 210          //                      MOV             output, A
 211          //                      SJMP    ONWARD
 212          //              STARTED:
 213          //                      JB              outEnd, ENDER
 214          //                      MOV             R0, output 
 215          //                      MOV             A, @R0
 216          //                      ADDC    A, ACC
 217          //                      MOV             @R0, A
 218          //                      JNC             OUT_0
 219          //                      CPL             audioL
 220          //              OUT_0:  
 221          //                      DJNZ    outputBit, ONWARD
 222          //                      MOV             outputBit, #0x08
 223          //                      DEC             output
 224          //                      DJNZ    outByte, ONWARD
 225          //                      MOV             outByte, #BUFFER_LENGTH
 226          //                      SETB    outEnd
 227          //                      SJMP    ONWARD
 228          //              ENDER:
 229          //                      CLR             outStart
 230          //                      CLR             audioL
 231          //                      CLR             outEnd
 232          //                      SETB    outEmpty
 233          //              ONWARD:
 234          //                      POP     ACC
 235          //                      POP     PSW
 236          //              #pragma ENDASM
 237          //}
 238          
 239          /***********************************************************************
 240          DESC:    Starts timer 0
 241          RETURNS: Nothing
 242          CAUTION: timers_init must be called first
 243          ************************************************************************/
 244          void timers_starttimer0
 245            (
 246            void
 247            )
 248          {
 249   1        TR0 = 1;
 250   1      } // timers_starttimer0
 251          
 252          /***********************************************************************
 253          DESC:    Stops timer 0
 254          RETURNS: Nothing
 255          CAUTION: timers_init must be called first
 256          ************************************************************************/
 257          void timers_stoptimer0
 258            (
 259            void
 260            )
 261          {
 262   1        TR0 = 0;
 263   1      } // timers_stoptimer0
 264          
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 13  

 265          
C51 COMPILER V8.12   TIMERS                                                                01/21/2011 22:04:57 PAGE 14  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


timers_starttimer0 . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
outputSmoother . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0000H  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
IP0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
CMP1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
timers_stoptimer0. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
smootherCnt. . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
ADMODA . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
inputBitSmoother . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
timers_init. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
output . . . . . . . . . . . . . . . .  PUBLIC   DATA   PTR      0001H  3
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
byte . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
word . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
IP0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
inputByte. . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
IP1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
outputByte . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0004H  1
TCR20. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
startBit . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
inputBuf . . . . . . . . . . . . . . .  EXTERN   DATA   ARRAY    -----  6
outputBit. . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0005H  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
I2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
inEmpty. . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
outStart . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
curBit . . . . . . . . . . . . . . . .  PUBLIC   DATA   U_CHAR   0006H  1
outEmpty . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
inByte . . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
outByte. . . . . . . . . . . . . . . .  EXTERN   DATA   U_CHAR   -----  1
outEnd . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
inBuf. . . . . . . . . . . . . . . . .  EXTERN   DATA   ARRAY    -----  6
TAMOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
timers_isr0. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
outBuf . . . . . . . . . . . . . . . .  EXTERN   DATA   ARRAY    -----  6
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    348    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
